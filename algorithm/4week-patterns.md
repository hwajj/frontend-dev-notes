# ğŸ§© **4ì£¼ì°¨ ì•Œê³ ë¦¬ì¦˜ ì •ë¦¬ ë…¸íŠ¸**

> ì£¼ì œ: Sliding Window / DFS-Backtracking / BFS / Binary Search ì‘ìš©
> ëª©í‘œ: ê° ì•Œê³ ë¦¬ì¦˜ì˜ ëŒ€í‘œ ë¬¸ì œë¥¼ ì˜ˆì‹œë¡œ ê°œë…, ì…ë ¥Â·ì¶œë ¥, ì½”ë“œ, í¬ì¸íŠ¸ê¹Œì§€ í•œëˆˆì— ë³´ê¸°

---

## 1ï¸âƒ£ Sliding Window â€” í™•ì¥í˜•

### ğŸ“˜ **ë¬¸ì œ**

**LeetCode 76. Minimum Window Substring**

> ë¬¸ìì—´ `s`, `t`ê°€ ì£¼ì–´ì§ˆ ë•Œ,
> `t`ì˜ ëª¨ë“  ë¬¸ìë¥¼ í¬í•¨í•˜ëŠ” `s`ì˜ ê°€ì¥ ì§§ì€ ë¶€ë¶„ ë¬¸ìì—´ì„ êµ¬í•˜ë¼.
> ì—†ìœ¼ë©´ `""`ì„ ë°˜í™˜.

---

### ğŸ’¬ **ì…ì¶œë ¥ ì˜ˆì‹œ**

| ì…ë ¥                                 | ì¶œë ¥       |
| ---------------------------------- | -------- |
| s = `"ADOBECODEBANC"`, t = `"ABC"` | `"BANC"` |
| s = `"a"`, t = `"a"`               | `"a"`    |
| s = `"a"`, t = `"aa"`              | `""`     |

---

### ğŸ’» **ì½”ë“œ + ì£¼ì„**

```js
// âœ… ìµœì†Œ ìœˆë„ìš° ë¶€ë¶„ ë¬¸ìì—´ (Minimum Window Substring)
let need = new Map();                     // tì˜ ê° ë¬¸ìì˜ í•„ìš” ê°œìˆ˜ ì €ì¥
for (let ch of t) need.set(ch, (need.get(ch) || 0) + 1);

let missing = t.length;                   // ì•„ì§ ì±„ì›Œì•¼ í•  ë¬¸ìì˜ ìˆ˜
let l = 0, start = 0, minLen = Infinity;  // í¬ì¸í„° ë° ê²°ê³¼ ì´ˆê¸°í™”

for (let r = 0; r < s.length; r++) {      // ì˜¤ë¥¸ìª½ í¬ì¸í„° í™•ì¥
  if (need.has(s[r]) && need.get(s[r]) > 0) missing--; // í•„ìš”í•œ ë¬¸ì ì±„ì›€
  need.set(s[r], (need.get(s[r]) || 0) - 1);

  // ëª¨ë“  ë¬¸ìë¥¼ ë‹¤ í¬í•¨í–ˆìœ¼ë©´ ì™¼ìª½ì„ ì¤„ì´ë©° ìµœì†Œ ê¸¸ì´ íƒìƒ‰
  while (missing === 0) {
    if (r - l + 1 < minLen) [start, minLen] = [l, r - l + 1];
    need.set(s[l], (need.get(s[l]) || 0) + 1);
    if (need.get(s[l]) > 0) missing++; // í•„ìš”í•œ ë¬¸ìê°€ ë¹ ì§
    l++;
  }
}

return minLen === Infinity ? "" : s.substring(start, start + minLen);
```
#### 1. í•„ìš” Mapê³¼ ë³€ìˆ˜ ì´ˆê¸°í™”
```javascript
let need = new Map();                     // tì˜ ê° ë¬¸ìì˜ í•„ìš” ê°œìˆ˜ ì €ì¥
for (let ch of t) need.set(ch, (need.get(ch) || 0) + 1);

let missing = t.length;                   // ì•„ì§ ì±„ì›Œì•¼ í•  ë¬¸ìì˜ ìˆ˜
let l = 0, start = 0, minLen = Infinity;  // í¬ì¸í„° ë° ê²°ê³¼ ì´ˆê¸°í™”

```
need = {A:1, B:1, C:1}

missing = 3

ì™¼ìª½ í¬ì¸í„° l = 0, ì˜¤ë¥¸ìª½ í¬ì¸í„° r ì•ìœ¼ë¡œ ì´ë™
#### 2. í¬ì¸í„° ì´ë™ ì‹œê°í™”

| ë‹¨ê³„ | r ë¬¸ì | missing | l í¬ì¸í„° ìœ„ì¹˜ | í˜„ì¬ window | ì„¤ëª…                      |
| -- | ---- | ------- | -------- | --------- | ----------------------- |
| 1  | A    | 2       | 0        | A         | í•„ìš”í•œ ë¬¸ì A ë°œê²¬, missing ê°ì†Œ |
| 2  | D    | 2       | 0        | AD        | í•„ìš” ì—†ëŠ” ë¬¸ì, missing ê·¸ëŒ€ë¡œ   |
| 3  | O    | 2       | 0        | ADO       | í•„ìš” ì—†ëŠ” ë¬¸ì, missing ê·¸ëŒ€ë¡œ   |
| 4  | B    | 1       | 0        | ADOB      | B ë°œê²¬, missing ê°ì†Œ        |
| 5  | E    | 1       | 0        | ADOBE     | í•„ìš” ì—†ëŠ” ë¬¸ì                |
| 6  | C    | 0       | 0        | ADOBEC    | ëª¨ë“  ë¬¸ì í¬í•¨ â†’ ì¶•ì†Œ ì‹œì‘        |
| 7  | ...  | ...     | 0â†’1â†’2    | BEC       | l ì´ë™í•˜ë©° ìµœì†Œ ê¸¸ì´ ê°±ì‹          |
---
#### 3. í•µì‹¬í¬ì¸íŠ¸ ê·¸ë¦¼
r í¬ì¸í„° â†’ ë¬¸ìì—´ ëê¹Œì§€ ì´ë™
l í¬ì¸í„° â†’ ì¡°ê±´ ë§Œì¡± ì‹œ ìµœì†Œ ê¸¸ì´ ìœ ì§€í•˜ë©° ì¶•ì†Œ
missing -> ì•„ì§ í•„ìš”í•œ ë¬¸ì ìˆ˜
need[ch] -> ë¬¸ìë³„ í•„ìš” ê°œìˆ˜
- í•µì‹¬: ì˜¤ë¥¸ìª½ í¬ì¸í„°ëŠ” ì¡°ê±´ ë§Œì¡± ì „ê¹Œì§€ í™•ì¥
- ì¡°ê±´ ë§Œì¡± ì‹œ ì™¼ìª½ í¬ì¸í„°ë¡œ ì¶•ì†Œí•˜ë©´ì„œ ìµœì†Œ ê¸¸ì´ ê°±ì‹ 

#### 4. ìµœì¢…ê²°ê³¼
- ìµœì†Œ ìœˆë„ìš°: "BANC"
- l, r í¬ì¸í„° ìµœì¢… ìœ„ì¹˜ì—ì„œ substring ì¶”ì¶œ

```
return minLen === Infinity ? "" : s.substring(start, start + minLen);
```

### âš¡ **í•µì‹¬ í¬ì¸íŠ¸**

| êµ¬ë¶„     | ë‚´ìš©                                              |
| ------ | ----------------------------------------------- |
| ì‹œê°„ë³µì¡ë„  | O(N)                                            |
| í•µì‹¬ í‚¤ì›Œë“œ | ìœˆë„ìš° í™•ì¥ + ì¶•ì†Œ, ë¬¸ì ê°œìˆ˜ ì¶”ì                            |
| ì‘ìš©     | Find Anagrams, Longest Substring Without Repeat |



---

## 2ï¸âƒ£ DFS / ë°±íŠ¸ë˜í‚¹ (Depth First Search + Backtracking)

### ğŸ“í•µì‹¬ ê°œë… ìš”ì•½

| ê°œë…                      | ì„¤ëª…                                                                   |
| ----------------------- | -------------------------------------------------------------------- |
| **DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰)**      | ëª¨ë“  ê°€ëŠ¥í•œ ê²½ë¡œë¥¼ ëê¹Œì§€ íƒìƒ‰í•œ ë’¤ ë˜ëŒì•„ì˜¤ëŠ” íƒìƒ‰ ë°©ì‹                                     |
| **Backtracking (ë°±íŠ¸ë˜í‚¹)** | ìœ ë§í•˜ì§€ ì•Šì€ ê²½ë¡œëŠ” ì¡°ê¸°ì— â€œê°€ì§€ì¹˜ê¸°(pruning)â€í•˜ë©° ë˜ëŒì•„ì˜´                               |
| **êµ¬ì¡° íŒ¨í„´**               | `push â†’ dfs(ì¬ê·€) â†’ pop` í˜•íƒœë¡œ íƒìƒ‰ ê²½ë¡œë¥¼ ì¡°ë¦½                                 |
| **ì¢…ë£Œ ì¡°ê±´ (base case)**   | í˜„ì¬ ê²½ë¡œ(path)ê°€ ì›í•˜ëŠ” ê¸¸ì´ë‚˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ ê²°ê³¼ì— ì¶”ê°€                                 |
| **í™œìš© ë¶„ì•¼**               | ì¡°í•©(Combinations), ìˆœì—´(Permutations), ë¶€ë¶„ì§‘í•©(Subsets), N-Queen, Sudoku ë“± |

---

### ğŸŒ°ì˜ˆì‹œ: **LeetCode 77. Combinations**

> 1ë¶€í„° nê¹Œì§€ì˜ ìˆ˜ ì¤‘ì—ì„œ **ì„œë¡œ ë‹¤ë¥¸ kê°œë¥¼ ì„ íƒ**í•˜ëŠ” ëª¨ë“  ì¡°í•©ì„ êµ¬í•˜ë¼.

---

#### ğŸ’¬ ì…ì¶œë ¥ ì˜ˆì‹œ

| ì…ë ¥           | ì¶œë ¥                                      |
| ------------ | --------------------------------------- |
| n = 4, k = 2 | `[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]` |
| n = 3, k = 1 | `[[1],[2],[3]]`                         |

---

#### ğŸ’» ì½”ë“œ + ë‹¨ê³„ë³„ ì£¼ì„

```js
// âœ… ëª¨ë“  ì¡°í•© ìƒì„± (DFS + ë°±íŠ¸ë˜í‚¹)
function combine(n, k) {
  let res = [];   // ê²°ê³¼ ì €ì¥ìš© ë°°ì—´
  let path = [];  // í˜„ì¬ ì¡°í•©ì„ ë‹´ëŠ” ë°°ì—´ (í˜„ì¬ ìƒíƒœ)

  // ì¬ê·€ í•¨ìˆ˜ ì •ì˜
  function dfs(start) {
    // (1) ì¢…ë£Œ ì¡°ê±´: pathì˜ ê¸¸ì´ê°€ kì´ë©´ ì™„ì„±ëœ ì¡°í•©ì´ë¯€ë¡œ ê²°ê³¼ì— ì¶”ê°€
    if (path.length === k) {
      res.push([...path]);   // ê¹Šì€ ë³µì‚¬ë¡œ ê²°ê³¼ ì €ì¥
      return;
    }

    // (2) í˜„ì¬ startë¶€í„° nê¹Œì§€ ìˆ«ìë¥¼ í•˜ë‚˜ì”© ì„ íƒ
    for (let i = start; i <= n; i++) {
      path.push(i);      // ì„ íƒ
      dfs(i + 1);        // ë‹¤ìŒ ìˆ«ìë¶€í„° íƒìƒ‰ (ì¤‘ë³µ ë°©ì§€)
      path.pop();        // ì„ íƒ í•´ì œ â†’ ë°±íŠ¸ë˜í‚¹
    }
  }

  dfs(1);  // ì‹œì‘ê°’ 1ë¶€í„° íƒìƒ‰
  return res;
}
```

---

### ğŸ§­ íƒìƒ‰ íë¦„ ì˜ˆì‹œ (n=4, k=2)

```
start=1
 â”œâ”€ 1 ì„ íƒ â†’ dfs(2)
 â”‚   â”œâ”€ 2 ì„ íƒ â†’ [1,2] ì €ì¥
 â”‚   â”œâ”€ 3 ì„ íƒ â†’ [1,3] ì €ì¥
 â”‚   â””â”€ 4 ì„ íƒ â†’ [1,4] ì €ì¥
 â”œâ”€ 2 ì„ íƒ â†’ dfs(3)
 â”‚   â”œâ”€ 3 ì„ íƒ â†’ [2,3] ì €ì¥
 â”‚   â””â”€ 4 ì„ íƒ â†’ [2,4] ì €ì¥
 â””â”€ 3 ì„ íƒ â†’ dfs(4)
     â””â”€ 4 ì„ íƒ â†’ [3,4] ì €ì¥
```

ê²°ê³¼: `[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]`

---

### ğŸ’¡í•µì‹¬ í¬ì¸íŠ¸ ìš”ì•½

| í•­ëª©      | ì„¤ëª…                                                  |
| ------- | --------------------------------------------------- |
| íƒìƒ‰ êµ¬ì¡°   | DFSë¡œ ê°€ëŠ¥í•œ ëª¨ë“  ê²½ë¡œë¥¼ ëê¹Œì§€ íƒìƒ‰                              |
| ë°±íŠ¸ë˜í‚¹ ì—­í•  | í˜„ì¬ ê²½ë¡œê°€ ì¡°ê±´ì„ ë§Œì¡±í•˜ê±°ë‚˜ ë„˜ì¹˜ë©´ â€œë˜ëŒì•„ê°â€                         |
| ì‹œê°„ë³µì¡ë„   | O(2â¿) (ëª¨ë“  ë¶€ë¶„ì§‘í•© íƒìƒ‰ ìˆ˜ì¤€)                               |
| ì½”ë“œ íŒ¨í„´   | `path.push()` â†’ `dfs()` â†’ `path.pop()`              |
| ì‘ìš©      | Subsets / Permutations / Combination Sum / N-Queens |

---

> **ğŸ‘‰ í•µì‹¬ ë¬¸ì¥ ìš”ì•½:**
> DFSëŠ” â€œëª¨ë“  ê²½ìš°ë¥¼ ëê¹Œì§€ ë‚´ë ¤ê°€ ë³¸ë‹¤â€,
> ë°±íŠ¸ë˜í‚¹ì€ â€œí•„ìš” ì—†ëŠ” ê¸¸ì€ ë¹¨ë¦¬ ëŒì•„ì˜¨ë‹¤â€.

---


ì™„ë²½í•´ìš” ğŸ™Œ ì§€ê¸ˆ ë…¸íŠ¸ê°€ â€œì½”ë“œ ì¤‘ì‹¬ êµ¬ì¡°â€ë¼ ì•„ì£¼ ì¢‹ì•„ìš”.
ì´ì œ BFSì™€ Binary Searchì—ë„ **ê°œë…Â·ì‹œê°í™”Â·ë¡œì§ ì´ìœ  ì„¤ëª…**ì„ ë§ë¶™ì´ë©´ ì™„ì „í•œ â€œì•”ê¸°+ì´í•´í˜• ì •ë¦¬ë…¸íŠ¸â€ê°€ ë©ë‹ˆë‹¤.
ì•„ë˜ëŠ” ê°™ì€ í˜•ì‹ì„ ìœ ì§€í•˜ë©´ì„œ **BFS / Binary Search ì‘ìš© ë³´ê°• ë²„ì „**ì´ì—ìš” ğŸ‘‡

---

## 3ï¸âƒ£ BFS (Breadth First Search, ë„ˆë¹„ ìš°ì„  íƒìƒ‰)

### ğŸ“í•µì‹¬ ê°œë… ìš”ì•½

| ê°œë…        | ì„¤ëª…                                       |
| --------- | ---------------------------------------- |
| **BFS**   | ì‹œì‘ì ì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œ(ì´ì›ƒ)ë¶€í„° íƒìƒ‰í•´ ë‚˜ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜          |
| **ìë£Œêµ¬ì¡°**  | **í(Queue)** ì‚¬ìš© â€” ì„ ì…ì„ ì¶œ(FIFO)             |
| **íŠ¹ì§•**    | í•œ ë‹¨ê³„ì”© í™•ì¥í•˜ë¯€ë¡œ â€œìµœë‹¨ ê±°ë¦¬(ìµœì†Œ ë‹¨ê³„)â€ ë¬¸ì œì— ì í•©        |
| **ë°©ë¬¸ ê´€ë¦¬** | `visited` ì§‘í•©ì„ ì¨ì„œ ì¤‘ë³µ íƒìƒ‰ ë°©ì§€                |
| **í™œìš© ë¶„ì•¼** | ê·¸ë˜í”„ ìµœë‹¨ ê²½ë¡œ, ë¯¸ë¡œ íƒìƒ‰, Word Ladder, ë„¤íŠ¸ì›Œí¬ íƒìƒ‰ ë“± |

---

### ğŸ“˜ **ë¬¸ì œ**

**LeetCode 127. Word Ladder**

> ë‹¨ì–´ beginWord â†’ endWordë¡œ ë³€í™˜í•  ë•Œ,
> í•œ ë²ˆì— í•œ ê¸€ìë§Œ ë°”ê¿€ ìˆ˜ ìˆê³  ê° ë‹¨ê³„ ë‹¨ì–´ëŠ” `wordList` ì•ˆì— ìˆì–´ì•¼ í•œë‹¤.
> **ìµœë‹¨ ë³€í™˜ ë‹¨ê³„ ìˆ˜**ë¥¼ êµ¬í•˜ë¼.

---

### ğŸ’¬ **ì…ì¶œë ¥ ì˜ˆì‹œ**

| ì…ë ¥                                                                                         | ì¶œë ¥  |
| ------------------------------------------------------------------------------------------ | --- |
| beginWord = `"hit"`, endWord = `"cog"`, wordList = `["hot","dot","dog","lot","log","cog"]` | `5` |
| beginWord = `"hit"`, endWord = `"cog"`, wordList = `["hot","dot","dog","lot","log"]`       | `0` |

ë³€í™˜ ê²½ë¡œ ì˜ˆì‹œ

```
hit â†’ hot â†’ dot â†’ dog â†’ cog â†’ (ì´ 5ë‹¨ê³„)
```

---

### ğŸ’¡ ê°œë… íë¦„ ì‹œê°í™”

```
Level 0: hit
Level 1: hot
Level 2: dot, lot
Level 3: dog, log
Level 4: cog
=> ì´ 5ë‹¨ê³„
```

---

### ğŸ’» **ì½”ë“œ + ì£¼ì„**

```js
// âœ… BFS ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰ (Word Ladder)
function bfsShortestPath(start, end, graph) {
  let queue = [[start, 1]];          // [ë‹¨ì–´, ê±°ë¦¬]
  let visited = new Set([start]);    // ë°©ë¬¸ ê¸°ë¡ (ì¤‘ë³µ ë°©ì§€)

  while (queue.length) {
    let [word, dist] = queue.shift(); // íì—ì„œ í•˜ë‚˜ êº¼ëƒ„
    if (word === end) return dist;    // ëª©ì ì§€ ë„ì°© â†’ ê±°ë¦¬ ë°˜í™˜

    // ì¸ì ‘(í•œ ê¸€ì ì°¨ì´) ë‹¨ì–´ ìˆœíšŒ
    for (let nei of graph[word] || []) {
      if (!visited.has(nei)) {
        visited.add(nei);             // ë°©ë¬¸ í‘œì‹œ
        queue.push([nei, dist + 1]);  // ê±°ë¦¬ 1 ì¦ê°€ í›„ íì— ì¶”ê°€
      }
    }
  }

  return 0; // endWordë¡œ ë³€í™˜ ë¶ˆê°€ëŠ¥
}
```

---

### âš™ï¸ **ë¡œì§ ì •ë¦¬**

1. íì— ì‹œì‘ ë‹¨ì–´ì™€ ê±°ë¦¬(1)ë¥¼ ë„£ìŒ
2. íì—ì„œ í•˜ë‚˜ì”© êº¼ë‚´ë©´ì„œ ì¸ì ‘ ë‹¨ì–´ íƒìƒ‰
3. ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ íì— ì¶”ê°€ (ê±°ë¦¬ +1)
4. ëª©í‘œ ë‹¨ì–´ë¥¼ ë§Œë‚˜ë©´ ê·¸ë•Œì˜ ê±°ë¦¬ ë°˜í™˜
5. íê°€ ë¹„ë©´ ë³€í™˜ ë¶ˆê°€ â†’ 0 ë°˜í™˜

---

### âš¡ **í•µì‹¬ í¬ì¸íŠ¸**

| êµ¬ë¶„    | ë‚´ìš©                                          |
| ----- | ------------------------------------------- |
| ì‹œê°„ë³µì¡ë„ | O(V + E)                                    |
| ìë£Œêµ¬ì¡°  | í (FIFO)                                    |
| íƒìƒ‰ë°©ì‹  | í•œ ë‹¨ê³„ì”© í™•ì¥ â†’ ìµœë‹¨ ê±°ë¦¬ ë³´ì¥                         |
| ì‘ìš©    | ë¯¸ë¡œ ìµœë‹¨ ê±°ë¦¬, Graph Traversal, Friend Network ë“± |

---

### âœ… **í•œ ì¤„ ìš”ì•½**

> BFSëŠ” â€œê°€ê¹Œìš´ ë…¸ë“œë¶€í„° íƒìƒ‰í•˜ëŠ” ìµœë‹¨ ê±°ë¦¬ ì•Œê³ ë¦¬ì¦˜â€.
> **Queue + ë°©ë¬¸ ì²´í¬ = ìµœì†Œ ë‹¨ê³„ íƒìƒ‰** ê³µì‹.

---

## 4ï¸âƒ£ Binary Search (ì‘ìš©: Lower Bound / Upper Bound)

### ğŸ“í•µì‹¬ ê°œë… ìš”ì•½

| ê°œë…                        | ì„¤ëª…                          |
| ------------------------- | --------------------------- |
| **Binary Search (ì´ì§„ íƒìƒ‰)** | ì •ë ¬ëœ ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ë©° íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜   |
| **Lower Bound**           | **target ì´ìƒ**ì´ ì²˜ìŒ ë‚˜íƒ€ë‚˜ëŠ” ì¸ë±ìŠ¤  |
| **Upper Bound**           | **target ì´ˆê³¼**ê°€ ì²˜ìŒ ë‚˜íƒ€ë‚˜ëŠ” ì¸ë±ìŠ¤  |
| **í•µì‹¬ ì•„ì´ë””ì–´**               | mid ë¹„êµ ê²°ê³¼ë¡œ íƒìƒ‰ ë²”ìœ„ë¥¼ ì ˆë°˜ì”© ì¤„ì¸ë‹¤.  |
| **í™œìš© ë¶„ì•¼**                 | ì‚½ì… ìœ„ì¹˜, ë²”ìœ„ ì°¾ê¸°, LIS, Kë²ˆì§¸ ì›ì†Œ ë“± |

---

### ğŸ“˜ **ë¬¸ì œ**

**LeetCode 35. Search Insert Position**

> ì •ë ¬ëœ ë°°ì—´ `nums`ì—ì„œ `target`ì˜ ì¸ë±ìŠ¤ë¥¼ ì°¾ê³ ,
> ì—†ìœ¼ë©´ **ì‚½ì…ë  ìœ„ì¹˜**ë¥¼ ë°˜í™˜í•˜ë¼.
> (ì¦‰, `Lower Bound` ë¬¸ì œ.)

---

### ğŸ’¬ **ì…ì¶œë ¥ ì˜ˆì‹œ**

| ì…ë ¥                             | ì¶œë ¥  |
| ------------------------------ | --- |
| nums = `[1,3,5,6]`, target = 5 | `2` |
| nums = `[1,3,5,6]`, target = 2 | `1` |
| nums = `[1,3,5,6]`, target = 7 | `4` |

---

### ğŸ’¡ ì‹œê°ì  ê°œë…

```
nums = [1,3,5,6]
target = 4
          â†‘
lowerBound = 2 (ì²« ë²ˆì§¸ 4 ì´ìƒ ìœ„ì¹˜)
```

---

### ğŸ’» **ì½”ë“œ + ì£¼ì„**

```js
// âœ… Lower Bound (ì²« ë²ˆì§¸ target ì´ìƒ ìœ„ì¹˜)
function lowerBound(nums, target) {
  let l = 0, r = nums.length;             // íƒìƒ‰ êµ¬ê°„ [l, r)
  while (l < r) {
    let mid = Math.floor((l + r) / 2);    // ì¤‘ì•™ ì¸ë±ìŠ¤
    if (nums[mid] < target) l = mid + 1;  // targetë³´ë‹¤ ì‘ìœ¼ë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
    else r = mid;                         // target ì´ìƒì´ë©´ ì™¼ìª½ ë²”ìœ„ë¡œ ì¢í˜
  }
  return l;                               // ì²« ë²ˆì§¸ target ì´ìƒ ì¸ë±ìŠ¤ ë°˜í™˜
}
```

---

### âš™ï¸ **ë¡œì§ ì •ë¦¬**

1. ì •ë ¬ëœ ë°°ì—´ì—ì„œ ì¤‘ì•™ê°’(mid)ì„ ë¹„êµ
2. `nums[mid] < target`ì´ë©´ ì™¼ìª½ì€ ë²„ë¦¬ê³  ì˜¤ë¥¸ìª½ íƒìƒ‰
3. `nums[mid] >= target`ì´ë©´ ì˜¤ë¥¸ìª½ ë²„ë¦¬ê³  ì™¼ìª½ ìœ ì§€
4. lê³¼ rì´ ë§Œë‚˜ëŠ” ì§€ì ì´ **ì‚½ì… ê°€ëŠ¥í•œ ìµœì†Œ ìœ„ì¹˜**

---

### âš¡ **í•µì‹¬ í¬ì¸íŠ¸**

| êµ¬ë¶„    | ë‚´ìš©                                            |
| ----- | --------------------------------------------- |
| ì‹œê°„ë³µì¡ë„ | O(log N)                                      |
| íƒìƒ‰ ëŒ€ìƒ | ì •ë ¬ëœ ë°°ì—´                                        |
| ì‘ìš©    | Search Insert, LIS, Range Counting, Median ì°¾ê¸° |
| ì£¼ì˜    | í•­ìƒ **ì •ë ¬ ì „ì œ** í•„ìš”                               |

---

### âœ… **í•œ ì¤„ ìš”ì•½**

> Binary SearchëŠ” â€œíƒìƒ‰ ë²”ìœ„ë¥¼ ë°˜ìœ¼ë¡œ ì¤„ì´ëŠ” ì‚¬ê³ ë²•â€.
> **Lower Bound**ëŠ” â€œtarget ì´ìƒì´ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ìœ„ì¹˜â€ë¥¼ ì°¾ëŠ” ì‘ìš© íŒ¨í„´.

---


## âœ… 4ì£¼ì°¨ í•œëˆˆ ì •ë¦¬í‘œ

| ì•Œê³ ë¦¬ì¦˜               | ëŒ€í‘œ ë¬¸ì œ                    | ì…ë ¥           | ì¶œë ¥         | í•µì‹¬ ì•„ì´ë””ì–´         | ì‹œê°„ë³µì¡ë„    |
| ------------------ | ------------------------ | ------------ | ---------- | --------------- | -------- |
| Sliding Window     | Minimum Window Substring | s, t         | ìµœì†Œ ìœˆë„ìš° ë¬¸ìì—´ | í™•ì¥ í›„ ì¡°ê±´ ë§Œì¡± ì‹œ ì¶•ì†Œ | O(N)     |
| DFS / Backtracking | Combinations             | n, k         | ëª¨ë“  ì¡°í•© ë¦¬ìŠ¤íŠ¸  | ì¬ê·€ + ë°±íŠ¸ë˜í‚¹       | O(2â¿)    |
| BFS                | Word Ladder              | ì‹œì‘, ëª©í‘œ, ê·¸ë˜í”„  | ìµœë‹¨ ê±°ë¦¬      | í íƒìƒ‰ìœ¼ë¡œ ìµœì†Œ ë‹¨ê³„    | O(V+E)   |
| Binary Search      | Search Insert Position   | nums, target | ì¸ë±ìŠ¤        | Lower Bound íƒìƒ‰  | O(log N) |

---
