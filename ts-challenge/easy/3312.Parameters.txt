//ë‚´ì¥ ì œë„¤ë¦­ Parameters<T>ë¥¼ ì´ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  êµ¬í˜„í•˜ì„¸ìš”.

//fooëŠ” í•¨ìˆ˜
const foo = (arg1: string, arg2: number): void => {};

//ì–´ë–¤ í•¨ìˆ˜ íƒ€ì… Tê°€ ìˆì„ ë•Œ, ê·¸ í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ë“¤ì„ íŠœí”Œ í˜•íƒœë¡œ ì¶”ì¶œí•¨
type FunctionParamsType = MyParameters<typeof foo>; // [arg1: string, arg2: number]


// ğŸ“Œ 
type MyParameters<> = {

}

export {};

/**
 1. T extends (...args: any[]) => any
 TëŠ” ë°˜ë“œì‹œ í•¨ìˆ˜ íƒ€ì…ì´ì–´ì•¼ í•œë‹¤ëŠ” ì œì•½
 ì´ í•¨ìˆ˜ëŠ” ì–´ë–¤ ë§¤ê°œë³€ìˆ˜(...args)ë¥¼ ë°›ê³ , ì–´ë–¤ ê°’ì„ ë°˜í™˜í•´ë„ ê´œì°®ìŒ

 2. T extends (...args: infer S) => any
 ì¡°ê±´ë¶€ íƒ€ì… + infer í‚¤ì›Œë“œ
 Tê°€ ì‹¤ì œë¡œ í•¨ìˆ˜ë¼ë©´, ë§¤ê°œë³€ìˆ˜ ë¶€ë¶„ (...args)ì—ì„œ íƒ€ì…ì„ ì¶”ë¡ í•˜ì—¬ Sì— ë‹´ìŒ
 ex)
   T = (x: string, y: number) => void
   â†’ infer S = [x: string, y: number]

 3. ? S : any
 ì¶”ë¡ ì— ì„±ê³µí–ˆìœ¼ë©´ Së¥¼ ë°˜í™˜

 ì‹¤íŒ¨í•˜ë©´ any ë°˜í™˜ (ì›ë˜ ë‚´ì¥ íƒ€ì…ì€ neverë¥¼ ì”€)


 *
 *
 */
